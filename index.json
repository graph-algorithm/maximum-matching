[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/addDefaultWeight.js",
    "content": "const addDefaultWeight = (edges) => edges.map(([u, v, w]) => [u, v, w || 1]);\nexport default addDefaultWeight;\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/addDefaultWeight.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "function",
    "name": "addDefaultWeight",
    "memberof": "src/addDefaultWeight.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/addDefaultWeight.js~addDefaultWeight",
    "access": "public",
    "export": true,
    "importPath": "@graph-algorithm/maximum-matching/src/addDefaultWeight.js",
    "importStyle": "addDefaultWeight",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "params": [
      {
        "name": "edges",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 50,
    "kind": "file",
    "name": "src/cardinality/approx/bipartite.js",
    "content": "import general from './general.js';\n\nexport default general;\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/cardinality/approx/bipartite.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 51,
    "kind": "file",
    "name": "src/cardinality/approx/general.js",
    "content": "import general from '../opt/general.js';\n\nconst generalApprox = (edges, _eps) => general(edges);\nexport default generalApprox;\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/cardinality/approx/general.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 52,
    "kind": "function",
    "name": "generalApprox",
    "memberof": "src/cardinality/approx/general.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cardinality/approx/general.js~generalApprox",
    "access": "public",
    "export": true,
    "importPath": "@graph-algorithm/maximum-matching/src/cardinality/approx/general.js",
    "importStyle": "generalApprox",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "edges",
        "types": [
          "*"
        ]
      },
      {
        "name": "_eps",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 53,
    "kind": "file",
    "name": "src/cardinality/approx/index.js",
    "content": "import bipartite from './bipartite.js';\nimport general from './general.js';\n\nexport default general;\n\nexport {bipartite, general};\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/cardinality/approx/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 54,
    "kind": "file",
    "name": "src/cardinality/index.js",
    "content": "import approx from './approx/index.js';\nimport opt from './opt/index.js';\n\nexport default opt;\n\nexport {approx, opt};\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/cardinality/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 55,
    "kind": "file",
    "name": "src/cardinality/opt/bipartite.js",
    "content": "import general from './general.js';\n\nexport default general;\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/cardinality/opt/bipartite.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 56,
    "kind": "file",
    "name": "src/cardinality/opt/general.js",
    "content": "import blossomNoChecks from '../../core/blossomNoChecks.js';\nimport addDefaultWeight from '../../addDefaultWeight.js';\n\nconst general = (edges) => blossomNoChecks(addDefaultWeight(edges), true);\n\nexport default general;\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/cardinality/opt/general.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 57,
    "kind": "function",
    "name": "general",
    "memberof": "src/cardinality/opt/general.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cardinality/opt/general.js~general",
    "access": "public",
    "export": true,
    "importPath": "@graph-algorithm/maximum-matching/src/cardinality/opt/general.js",
    "importStyle": "general",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "params": [
      {
        "name": "edges",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 58,
    "kind": "file",
    "name": "src/cardinality/opt/index.js",
    "content": "import bipartite from './bipartite.js';\nimport general from './general.js';\n\nexport default general;\n\nexport {bipartite, general};\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/cardinality/opt/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 59,
    "kind": "file",
    "name": "src/core/blossom/blossom.js",
    "content": "import assert from 'assert';\nimport min from './min.js';\nimport rotate from './rotate.js';\nimport verifyOptimum from './verifyOptimum.js';\nimport checkDelta2 from './checkDelta2.js';\nimport checkDelta3 from './checkDelta3.js';\nimport statistics from './statistics.js';\nimport endpoints from './endpoints.js';\nimport neighbours from './neighbours.js';\nimport blossomLeaves from './blossomLeaves.js';\nimport blossomEdges from './blossomEdges.js';\n\n// Adapted from http://jorisvr.nl/maximummatching.html\n// All credit for the implementation goes to Joris van Rantwijk [http://jorisvr.nl].\n\n// ** Original introduction below **\n\n// Weighted maximum matching in general graphs.\n\n// The algorithm is taken from \"Efficient Algorithms for Finding Maximum\n// Matching in Graphs\" by Zvi Galil, ACM Computing Surveys, 1986.\n// It is based on the \"blossom\" method for finding augmenting paths and\n// the \"primal-dual\" method for finding a matching of maximum weight, both\n// due to Jack Edmonds.\n// Some ideas came from \"Implementation of algorithms for maximum matching\n// on non-bipartite graphs\" by H.J. Gabow, Standford Ph.D. thesis, 1973.\n\n// A C program for maximum weight matching by Ed Rothberg was used extensively\n// to validate this new code.\n\nexport default function blossom(CHECK_OPTIMUM, CHECK_DELTA) {\n\t// Check delta2/delta3 computation after every substage;\n\t// only works on integer weights, slows down the algorithm to O(n^4).\n\tif (CHECK_DELTA === undefined) CHECK_DELTA = false;\n\n\t// Check optimality of solution before returning; only works on integer weights.\n\tif (CHECK_OPTIMUM === undefined) CHECK_OPTIMUM = true;\n\n\t/**\n\t * Compute a maximum-weighted matching in the general undirected\n\t * weighted graph given by \"edges\". If \"maxCardinality\" is true,\n\t * only maximum-cardinality matchings are considered as solutions.\n\t *\n\t * Edges is a sequence of tuples (i, j, wt) describing an undirected\n\t * edge between vertex i and vertex j with weight wt.  There is at most\n\t * one edge between any two vertices; no vertex has an edge to itthis.\n\t * Vertices are identified by consecutive, non-negative integers.\n\t *\n\t * Return a list \"mate\", such that mate[i] === j if vertex i is\n\t * matched to vertex j, and mate[i] === -1 if vertex i is not matched.\n\t *\n\t * This function takes time O(n^3)\n\t *\n\t * @param {Array} edges\n\t * @param {Boolean} maxCardinality\n\t * @return {Array}\n\t */\n\n\tconst maxWeightMatching = (edges, maxCardinality = false) => {\n\t\t// Vertices are numbered 0 .. (nvertex-1).\n\t\t// Non-trivial blossoms are numbered nvertex .. (2*nvertex-1)\n\t\t//\n\t\t// Edges are numbered 0 .. (nedge-1).\n\t\t// Edge endpoints are numbered 0 .. (2*nedge-1), such that endpoints\n\t\t// (2*k) and (2*k+1) both belong to edge k.\n\t\t//\n\t\t// Many terms used in the comments (sub-blossom, T-vertex) come from\n\t\t// the paper by Galil; read the paper before reading this code.\n\n\t\t// Deal swiftly with empty graphs.\n\t\tif (edges.length === 0) return [];\n\n\t\t// Count vertices + find the maximum edge weight.\n\t\tconst [nvertex, nedge, maxweight] = statistics(edges);\n\n\t\t// If p is an edge endpoint,\n\t\t// endpoint[p] is the vertex to which endpoint p is attached.\n\t\t// Not modified by the algorithm.\n\t\tconst endpoint = endpoints(nedge, edges);\n\n\t\t// If v is a vertex,\n\t\t// neighbend[v] is the list of remote endpoints of the edges attached to v.\n\t\t// Not modified by the algorithm.\n\t\tconst neighbend = neighbours(nvertex, nedge, edges);\n\n\t\t// If v is a vertex,\n\t\t// mate[v] is the remote endpoint of its matched edge, or -1 if it is single\n\t\t// (i.e. endpoint[mate[v]] is v's partner vertex).\n\t\t// Initially all vertices are single; updated during augmentation.\n\t\tconst mate = new Array(nvertex).fill(-1);\n\n\t\t// If b is a top-level blossom,\n\t\t// label[b] is 0 if b is unlabeled (free);\n\t\t//             1 if b is an S-vertex/blossom;\n\t\t//             2 if b is a T-vertex/blossom.\n\t\t// The label of a vertex is found by looking at the label of its\n\t\t// top-level containing blossom.\n\t\t// If v is a vertex inside a T-blossom,\n\t\t// label[v] is 2 iff v is reachable from an S-vertex outside the blossom.\n\t\t// Labels are assigned during a stage and reset after each augmentation.\n\t\tconst label = new Array(2 * nvertex).fill(0);\n\n\t\t// If b is a labeled top-level blossom,\n\t\t// labelend[b] is the remote endpoint of the edge through which b obtained\n\t\t// its label, or -1 if b's base vertex is single.\n\t\t// If v is a vertex inside a T-blossom and label[v] === 2,\n\t\t// labelend[v] is the remote endpoint of the edge through which v is\n\t\t// reachable from outside the blossom.\n\t\tconst labelend = new Array(2 * nvertex).fill(-1);\n\n\t\t// If v is a vertex,\n\t\t// inblossom[v] is the top-level blossom to which v belongs.\n\t\t// If v is a top-level vertex, v is itthis a blossom (a trivial blossom)\n\t\t// and inblossom[v] === v.\n\t\t// Initially all vertices are top-level trivial blossoms.\n\t\tconst inblossom = new Array(nvertex);\n\t\tfor (let i = 0; i < nvertex; ++i) inblossom[i] = i;\n\n\t\t// If b is a sub-blossom,\n\t\t// blossomparent[b] is its immediate parent (sub-)blossom.\n\t\t// If b is a top-level blossom, blossomparent[b] is -1.\n\t\tconst blossomparent = new Array(2 * nvertex).fill(-1);\n\n\t\t// If b is a non-trivial (sub-)blossom,\n\t\t// blossomchilds[b] is an ordered list of its sub-blossoms, starting with\n\t\t// the base and going round the blossom.\n\t\tconst blossomchilds = new Array(2 * nvertex).fill(null);\n\n\t\t// If b is a (sub-)blossom,\n\t\t// blossombase[b] is its base VERTEX (i.e. recursive sub-blossom).\n\t\tconst blossombase = new Array(2 * nvertex);\n\t\tfor (let i = 0; i < nvertex; ++i) blossombase[i] = i;\n\t\tblossombase.fill(-1, nvertex, 2 * nvertex);\n\n\t\t// If b is a non-trivial (sub-)blossom,\n\t\t// blossomendps[b] is a list of endpoints on its connecting edges,\n\t\t// such that blossomendps[b][i] is the local endpoint of blossomchilds[b][i]\n\t\t// on the edge that connects it to blossomchilds[b][wrap(i+1)].\n\t\tconst blossomendps = new Array(2 * nvertex).fill(null);\n\n\t\t// If v is a free vertex (or an unreached vertex inside a T-blossom),\n\t\t// bestedge[v] is the edge to an S-vertex with least slack,\n\t\t// or -1 if there is no such edge.\n\t\t// If b is a (possibly trivial) top-level S-blossom,\n\t\t// bestedge[b] is the least-slack edge to a different S-blossom,\n\t\t// or -1 if there is no such edge.\n\t\t// This is used for efficient computation of delta2 and delta3.\n\t\tconst bestedge = new Array(2 * nvertex).fill(-1);\n\n\t\t// If b is a non-trivial top-level S-blossom,\n\t\t// blossombestedges[b] is a list of least-slack edges to neighbouring\n\t\t// S-blossoms, or null if no such list has been computed yet.\n\t\t// This is used for efficient computation of delta3.\n\t\tconst blossombestedges = new Array(2 * nvertex).fill(null);\n\n\t\t// List of currently unused blossom numbers.\n\t\tconst unusedblossoms = new Array(nvertex);\n\t\tfor (let i = 0; i < nvertex; ++i) unusedblossoms[i] = nvertex + i;\n\n\t\t// If v is a vertex,\n\t\t// dualvar[v] = 2 * u(v) where u(v) is the v's variable in the dual\n\t\t// optimization problem (multiplication by two ensures integer values\n\t\t// throughout the algorithm if all edge weights are integers).\n\t\t// If b is a non-trivial blossom,\n\t\t// dualvar[b] = z(b) where z(b) is b's variable in the dual optimization\n\t\t// problem.\n\t\tconst dualvar = new Array(2 * nvertex);\n\t\tdualvar.fill(maxweight, 0, nvertex);\n\t\tdualvar.fill(0, nvertex, 2 * nvertex);\n\n\t\t// If allowedge[k] is true, edge k has zero slack in the optimization\n\t\t// problem; if allowedge[k] is false, the edge's slack may or may not\n\t\t// be zero.\n\t\tconst allowedge = new Array(nedge).fill(false);\n\n\t\t// Queue of newly discovered S-vertices.\n\t\tlet queue = [];\n\n\t\t// Return 2 * slack of edge k (does not work inside blossoms).\n\t\tconst slack = (k) => {\n\t\t\tconst [i, j, wt] = edges[k];\n\t\t\treturn dualvar[i] + dualvar[j] - 2 * wt;\n\t\t};\n\n\t\t// Assign label t to the top-level blossom containing vertex w\n\t\t// and record the fact that w was reached through the edge with\n\t\t// remote endpoint p.\n\t\tconst assignLabel = (w, t, p) => {\n\t\t\tconsole.debug('DEBUG: assignLabel(' + w + ',' + t + ',' + p + ')');\n\t\t\tconst b = inblossom[w];\n\t\t\tassert(label[w] === 0 && label[b] === 0);\n\t\t\tassert(t === 1 || t === 2);\n\t\t\tlabel[w] = t;\n\t\t\tlabel[b] = t;\n\t\t\tlabelend[w] = p;\n\t\t\tlabelend[b] = p;\n\t\t\tbestedge[w] = -1;\n\t\t\tbestedge[b] = -1;\n\t\t\tif (t === 1) {\n\t\t\t\t// B became an S-vertex/blossom; add it(s vertices) to the queue.\n\t\t\t\tfor (const v of blossomLeaves(nvertex, blossomchilds, b)) {\n\t\t\t\t\tqueue.push(v);\n\t\t\t\t}\n\n\t\t\t\tconsole.debug('DEBUG: PUSH ' + queue);\n\t\t\t} else {\n\t\t\t\t// B became a T-vertex/blossom; assign label S to its mate.\n\t\t\t\t// (If b is a non-trivial blossom, its base is the only vertex\n\t\t\t\t// with an external mate.)\n\t\t\t\tconst base = blossombase[b];\n\t\t\t\tassert(mate[base] >= 0);\n\t\t\t\tassignLabel(endpoint[mate[base]], 1, mate[base] ^ 1);\n\t\t\t}\n\t\t};\n\n\t\t// Trace back from vertices v and w to discover either a new blossom\n\t\t// or an augmenting path. Return the base vertex of the new blossom or -1.\n\t\tconst scanBlossom = (v, w) => {\n\t\t\tconsole.debug('DEBUG: scanBlossom(' + v + ',' + w + ')');\n\t\t\t// Trace back from v and w, placing breadcrumbs as we go.\n\t\t\tconst path = [];\n\t\t\tlet base = -1;\n\t\t\twhile (v !== -1 || w !== -1) {\n\t\t\t\t// Look for a breadcrumb in v's blossom or put a new breadcrumb.\n\t\t\t\tlet b = inblossom[v];\n\t\t\t\tif (label[b] & 4) {\n\t\t\t\t\tbase = blossombase[b];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tassert(label[b] === 1);\n\t\t\t\tpath.push(b);\n\t\t\t\tlabel[b] = 5;\n\t\t\t\t// Trace one step back.\n\t\t\t\tassert(labelend[b] === mate[blossombase[b]]);\n\t\t\t\tif (labelend[b] === -1) {\n\t\t\t\t\t// The base of blossom b is single; stop tracing this path.\n\t\t\t\t\tv = -1;\n\t\t\t\t} else {\n\t\t\t\t\tv = endpoint[labelend[b]];\n\t\t\t\t\tb = inblossom[v];\n\t\t\t\t\tassert(label[b] === 2);\n\t\t\t\t\t// B is a T-blossom; trace one more step back.\n\t\t\t\t\tassert(labelend[b] >= 0);\n\t\t\t\t\tv = endpoint[labelend[b]];\n\t\t\t\t}\n\n\t\t\t\t// Swap v and w so that we alternate between both paths.\n\t\t\t\tif (w !== -1) {\n\t\t\t\t\tconst temporary_ = v;\n\t\t\t\t\tv = w;\n\t\t\t\t\tw = temporary_;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove breadcrumbs.\n\t\t\tfor (const b of path) label[b] = 1;\n\n\t\t\t// Return base vertex, if we found one.\n\t\t\treturn base;\n\t\t};\n\n\t\t// Construct a new blossom with given base, containing edge k which\n\t\t// connects a pair of S vertices. Label the new blossom as S; set its dual\n\t\t// variable to zero; relabel its T-vertices to S and add them to the queue.\n\t\tconst addBlossom = (base, k) => {\n\t\t\tlet v = edges[k][0];\n\t\t\tlet w = edges[k][1];\n\t\t\tconst bb = inblossom[base];\n\t\t\tlet bv = inblossom[v];\n\t\t\tlet bw = inblossom[w];\n\t\t\t// Create blossom.\n\t\t\tconst b = unusedblossoms.pop();\n\t\t\tconsole.debug(\n\t\t\t\t'DEBUG: addBlossom(' +\n\t\t\t\t\tbase +\n\t\t\t\t\t',' +\n\t\t\t\t\tk +\n\t\t\t\t\t') (v=' +\n\t\t\t\t\tv +\n\t\t\t\t\t' w=' +\n\t\t\t\t\tw +\n\t\t\t\t\t') -> ' +\n\t\t\t\t\tb,\n\t\t\t);\n\t\t\tblossombase[b] = base;\n\t\t\tblossomparent[b] = -1;\n\t\t\tblossomparent[bb] = b;\n\t\t\t// Make list of sub-blossoms and their interconnecting edge endpoints.\n\t\t\tconst path = [];\n\t\t\tblossomchilds[b] = path;\n\t\t\tconst endps = [];\n\t\t\tblossomendps[b] = endps;\n\t\t\t// Trace back from v to base.\n\t\t\twhile (bv !== bb) {\n\t\t\t\t// Add bv to the new blossom.\n\t\t\t\tblossomparent[bv] = b;\n\t\t\t\tpath.push(bv);\n\t\t\t\tendps.push(labelend[bv]);\n\t\t\t\tassert(\n\t\t\t\t\tlabel[bv] === 2 ||\n\t\t\t\t\t\t(label[bv] === 1 && labelend[bv] === mate[blossombase[bv]]),\n\t\t\t\t);\n\t\t\t\t// Trace one step back.\n\t\t\t\tassert(labelend[bv] >= 0);\n\t\t\t\tv = endpoint[labelend[bv]];\n\t\t\t\tbv = inblossom[v];\n\t\t\t}\n\n\t\t\t// Reverse lists, add endpoint that connects the pair of S vertices.\n\t\t\tpath.push(bb);\n\t\t\tpath.reverse();\n\t\t\tendps.reverse();\n\t\t\tendps.push(2 * k);\n\t\t\t// Trace back from w to base.\n\t\t\twhile (bw !== bb) {\n\t\t\t\t// Add bw to the new blossom.\n\t\t\t\tblossomparent[bw] = b;\n\t\t\t\tpath.push(bw);\n\t\t\t\tendps.push(labelend[bw] ^ 1);\n\t\t\t\tassert(\n\t\t\t\t\tlabel[bw] === 2 ||\n\t\t\t\t\t\t(label[bw] === 1 && labelend[bw] === mate[blossombase[bw]]),\n\t\t\t\t);\n\t\t\t\t// Trace one step back.\n\t\t\t\tassert(labelend[bw] >= 0);\n\t\t\t\tw = endpoint[labelend[bw]];\n\t\t\t\tbw = inblossom[w];\n\t\t\t}\n\n\t\t\t// Set label to S.\n\t\t\tassert(label[bb] === 1);\n\t\t\tlabel[b] = 1;\n\t\t\tlabelend[b] = labelend[bb];\n\t\t\t// Set dual variable to zero.\n\t\t\tdualvar[b] = 0;\n\t\t\t// Relabel vertices.\n\t\t\tfor (const v of blossomLeaves(nvertex, blossomchilds, b)) {\n\t\t\t\tif (label[inblossom[v]] === 2) {\n\t\t\t\t\t// This T-vertex now turns into an S-vertex because it becomes\n\t\t\t\t\t// part of an S-blossom; add it to the queue.\n\t\t\t\t\tqueue.push(v);\n\t\t\t\t}\n\n\t\t\t\tinblossom[v] = b;\n\t\t\t}\n\n\t\t\t// Compute blossombestedges[b].\n\n\t\t\tconst bestedgeto = new Array(2 * nvertex).fill(-1);\n\n\t\t\tconst length_ = path.length;\n\t\t\tfor (let z = 0; z < length_; ++z) {\n\t\t\t\tconst bv = path[z];\n\t\t\t\t// Walk this subblossom's least-slack edges.\n\t\t\t\tlet nblist = blossombestedges[bv];\n\t\t\t\tif (nblist === null) {\n\t\t\t\t\t// This subblossom does not have a list of least-slack edges;\n\t\t\t\t\t// get the information from the vertices.\n\t\t\t\t\tnblist = blossomEdges(nvertex, blossomchilds, neighbend, bv);\n\t\t\t\t}\n\n\t\t\t\tfor (const k of nblist) {\n\t\t\t\t\tconst [i, j] = edges[k];\n\t\t\t\t\tconst bj = inblossom[j] === b ? inblossom[i] : inblossom[j];\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tbj !== b &&\n\t\t\t\t\t\tlabel[bj] === 1 &&\n\t\t\t\t\t\t(bestedgeto[bj] === -1 || slack(k) < slack(bestedgeto[bj]))\n\t\t\t\t\t) {\n\t\t\t\t\t\tbestedgeto[bj] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Forget about least-slack edges of the subblossom.\n\t\t\t\tblossombestedges[bv] = null;\n\t\t\t\tbestedge[bv] = -1;\n\t\t\t}\n\n\t\t\tblossombestedges[b] = [];\n\t\t\tconst length_2 = bestedgeto.length;\n\t\t\tfor (let i = 0; i < length_2; ++i) {\n\t\t\t\tk = bestedgeto[i];\n\t\t\t\tif (k !== -1) blossombestedges[b].push(k);\n\t\t\t}\n\n\t\t\t// Select bestedge[b].\n\n\t\t\tconst length_3 = blossombestedges[b].length;\n\t\t\tif (length_3 > 0) {\n\t\t\t\tbestedge[b] = blossombestedges[b][0];\n\t\t\t\tfor (let i = 1; i < length_3; ++i) {\n\t\t\t\t\tk = blossombestedges[b][i];\n\t\t\t\t\tif (slack(k) < slack(bestedge[b])) {\n\t\t\t\t\t\tbestedge[b] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else bestedge[b] = -1;\n\n\t\t\tconsole.debug('DEBUG: blossomchilds[' + b + ']=' + blossomchilds[b]);\n\t\t};\n\n\t\t// Expand the given top-level blossom.\n\t\tconst expandBlossom = (b, endstage) => {\n\t\t\tconsole.debug(\n\t\t\t\t'DEBUG: expandBlossom(' + b + ',' + endstage + ') ' + blossomchilds[b],\n\t\t\t);\n\t\t\t// Convert sub-blossoms into top-level blossoms.\n\t\t\tfor (let i = 0; i < blossomchilds[b].length; ++i) {\n\t\t\t\tconst s = blossomchilds[b][i];\n\n\t\t\t\tblossomparent[s] = -1;\n\t\t\t\tif (s < nvertex) inblossom[s] = s;\n\t\t\t\telse if (endstage && dualvar[s] === 0) {\n\t\t\t\t\t// Recursively expand this sub-blossom.\n\t\t\t\t\texpandBlossom(s, endstage);\n\t\t\t\t} else {\n\t\t\t\t\tfor (const v of blossomLeaves(nvertex, blossomchilds, s)) {\n\t\t\t\t\t\tinblossom[v] = s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we expand a T-blossom during a stage, its sub-blossoms must be\n\t\t\t// relabeled.\n\t\t\tif (!endstage && label[b] === 2) {\n\t\t\t\t// Start at the sub-blossom through which the expanding\n\t\t\t\t// blossom obtained its label, and relabel sub-blossoms untili\n\t\t\t\t// we reach the base.\n\t\t\t\t// Figure out through which sub-blossom the expanding blossom\n\t\t\t\t// obtained its label initially.\n\t\t\t\tassert(labelend[b] >= 0);\n\t\t\t\tconst entrychild = inblossom[endpoint[labelend[b] ^ 1]];\n\t\t\t\t// Decide in which direction we will go round the blossom.\n\t\t\t\tlet j = blossomchilds[b].indexOf(entrychild);\n\t\t\t\tlet jstep;\n\t\t\t\tlet endptrick;\n\t\t\t\tlet stop;\n\t\t\t\tlet base;\n\t\t\t\tif (j & 1) {\n\t\t\t\t\t// Start index is odd; go forward.\n\t\t\t\t\tjstep = 1;\n\t\t\t\t\tendptrick = 0;\n\t\t\t\t\tstop = blossomchilds[b].length;\n\t\t\t\t\tbase = 0;\n\t\t\t\t} else {\n\t\t\t\t\t// Start index is even; go backward.\n\t\t\t\t\tjstep = -1;\n\t\t\t\t\tendptrick = 1;\n\t\t\t\t\tstop = 0;\n\t\t\t\t\tbase = blossomchilds[b].length;\n\t\t\t\t}\n\n\t\t\t\t// Move along the blossom until we get to the base.\n\t\t\t\tlet p = labelend[b];\n\t\t\t\twhile (j !== stop) {\n\t\t\t\t\t// Relabel the T-sub-blossom.\n\t\t\t\t\tlabel[endpoint[p ^ 1]] = 0;\n\t\t\t\t\tlabel[endpoint[blossomendps[b][j - endptrick] ^ endptrick ^ 1]] = 0;\n\t\t\t\t\tassignLabel(endpoint[p ^ 1], 2, p);\n\t\t\t\t\t// Step to the next S-sub-blossom and note its forward endpoint.\n\t\t\t\t\tallowedge[Math.floor(blossomendps[b][j - endptrick] / 2)] = true;\n\t\t\t\t\tj += jstep;\n\t\t\t\t\tp = blossomendps[b][j - endptrick] ^ endptrick;\n\t\t\t\t\t// Step to the next T-sub-blossom.\n\t\t\t\t\tallowedge[Math.floor(p / 2)] = true;\n\t\t\t\t\tj += jstep;\n\t\t\t\t}\n\n\t\t\t\t// Relabel the base T-sub-blossom WITHOUT stepping through to\n\t\t\t\t// its mate (so don't call assignLabel).\n\t\t\t\tlet bv = blossomchilds[b][0];\n\t\t\t\tlabel[endpoint[p ^ 1]] = 2;\n\t\t\t\tlabel[bv] = 2;\n\t\t\t\tlabelend[endpoint[p ^ 1]] = p;\n\t\t\t\tlabelend[bv] = p;\n\t\t\t\tbestedge[bv] = -1;\n\t\t\t\t// Continue along the blossom until we get back to entrychild.\n\t\t\t\tj = base + jstep;\n\t\t\t\twhile (blossomchilds[b][j] !== entrychild) {\n\t\t\t\t\t// Examine the vertices of the sub-blossom to see whether\n\t\t\t\t\t// it is reachable from a neighbouring S-vertex outside the\n\t\t\t\t\t// expanding blossom.\n\t\t\t\t\tbv = blossomchilds[b][j];\n\t\t\t\t\tif (label[bv] === 1) {\n\t\t\t\t\t\t// This sub-blossom just got label S through one of its\n\t\t\t\t\t\t// neighbours; leave it.\n\t\t\t\t\t\tj += jstep;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const v of blossomLeaves(nvertex, blossomchilds, bv)) {\n\t\t\t\t\t\tif (label[v] === 0) continue;\n\t\t\t\t\t\t// If the sub-blossom contains a reachable vertex, assign\n\t\t\t\t\t\t// label T to the sub-blossom.\n\t\t\t\t\t\tassert(label[v] === 2);\n\t\t\t\t\t\tassert(inblossom[v] === bv);\n\t\t\t\t\t\tlabel[v] = 0;\n\t\t\t\t\t\tlabel[endpoint[mate[blossombase[bv]]]] = 0;\n\t\t\t\t\t\tassignLabel(v, 2, labelend[v]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tj += jstep;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Recycle the blossom number.\n\t\t\tlabel[b] = -1;\n\t\t\tlabelend[b] = -1;\n\t\t\tblossomchilds[b] = null;\n\t\t\tblossomendps[b] = null;\n\t\t\tblossombase[b] = -1;\n\t\t\tblossombestedges[b] = null;\n\t\t\tbestedge[b] = -1;\n\t\t\tunusedblossoms.push(b);\n\t\t};\n\n\t\t// Swap matched/unmatched edges over an alternating path through blossom b\n\t\t// between vertex v and the base vertex. Keep blossom bookkeeping consistent.\n\t\tconst augmentBlossom = (b, v) => {\n\t\t\tconsole.debug('DEBUG: augmentBlossom(' + b + ',' + v + ')');\n\t\t\t// Bubble up through the blossom tree from vertex v to an immediate\n\t\t\t// sub-blossom of b.\n\t\t\tlet j;\n\t\t\tlet jstep;\n\t\t\tlet endptrick;\n\t\t\tlet stop;\n\t\t\tlet p;\n\t\t\tlet t = v;\n\t\t\twhile (blossomparent[t] !== b) t = blossomparent[t];\n\t\t\t// Recursively deal with the first sub-blossom.\n\t\t\tif (t >= nvertex) augmentBlossom(t, v);\n\t\t\t// Decide in which direction we will go round the blossom.\n\t\t\tj = blossomchilds[b].indexOf(t);\n\t\t\tconst i = j;\n\t\t\tconst length_ = blossomchilds[b].length;\n\t\t\tif (i & 1) {\n\t\t\t\t// Start index is odd; go forward.\n\t\t\t\tjstep = 1;\n\t\t\t\tendptrick = 0;\n\t\t\t\tstop = length_;\n\t\t\t} else {\n\t\t\t\t// Start index is even; go backward.\n\t\t\t\tjstep = -1;\n\t\t\t\tendptrick = 1;\n\t\t\t\tstop = 0;\n\t\t\t}\n\n\t\t\t// Move along the blossom until we get to the base.\n\t\t\twhile (j !== stop) {\n\t\t\t\t// Step to the next sub-blossom and augment it recursively.\n\t\t\t\tj += jstep;\n\t\t\t\tt = blossomchilds[b][j];\n\t\t\t\tp = blossomendps[b][j - endptrick] ^ endptrick;\n\t\t\t\tif (t >= nvertex) augmentBlossom(t, endpoint[p]);\n\t\t\t\t// Step to the next sub-blossom and augment it recursively.\n\t\t\t\tj += jstep;\n\t\t\t\tt = blossomchilds[b][Math.abs(j % length_)];\n\t\t\t\tif (t >= nvertex) augmentBlossom(t, endpoint[p ^ 1]);\n\t\t\t\t// Match the edge connecting those sub-blossoms.\n\t\t\t\tmate[endpoint[p]] = p ^ 1;\n\t\t\t\tmate[endpoint[p ^ 1]] = p;\n\t\t\t\tconsole.debug(\n\t\t\t\t\t'DEBUG: PAIR ' +\n\t\t\t\t\t\tendpoint[p] +\n\t\t\t\t\t\t' ' +\n\t\t\t\t\t\tendpoint[p ^ 1] +\n\t\t\t\t\t\t' (k=' +\n\t\t\t\t\t\tMath.floor(p / 2) +\n\t\t\t\t\t\t')',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Rotate the list of sub-blossoms to put the new base at the front.\n\t\t\trotate(blossomchilds[b], i);\n\t\t\trotate(blossomendps[b], i);\n\t\t\tblossombase[b] = blossombase[blossomchilds[b][0]];\n\t\t\tassert(blossombase[b] === v);\n\t\t};\n\n\t\t// Swap matched/unmatched edges over an alternating path between two\n\t\t// single vertices. The augmenting path runs through edge k, which\n\t\t// connects a pair of S vertices.\n\t\tconst augmentMatching = (k) => {\n\t\t\tconst v = edges[k][0];\n\t\t\tconst w = edges[k][1];\n\n\t\t\tconsole.debug(\n\t\t\t\t'DEBUG: augmentMatching(' + k + ') (v=' + v + ' w=' + w + ')',\n\t\t\t);\n\t\t\tconsole.debug('DEBUG: PAIR ' + v + ' ' + w + ' (k=' + k + ')');\n\n\t\t\tmatchVerticesAndFix(v, 2 * k + 1);\n\t\t\tmatchVerticesAndFix(w, 2 * k);\n\t\t};\n\n\t\tconst matchVerticesAndFix = (s, p) => {\n\t\t\t// Match vertex s to remote endpoint p. Then trace back from s\n\t\t\t// until we find a single vertex, swapping matched and unmatched\n\t\t\t// edges as we go.\n\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t\twhile (true) {\n\t\t\t\tconst bs = inblossom[s];\n\t\t\t\tassert(label[bs] === 1);\n\t\t\t\tassert(labelend[bs] === mate[blossombase[bs]]);\n\t\t\t\t// Augment through the S-blossom from s to base.\n\t\t\t\tif (bs >= nvertex) augmentBlossom(bs, s);\n\t\t\t\t// Update mate[s]\n\t\t\t\tmate[s] = p;\n\t\t\t\t// Trace one step back.\n\t\t\t\tif (labelend[bs] === -1) {\n\t\t\t\t\t// Reached single vertex; stop.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst t = endpoint[labelend[bs]];\n\t\t\t\tconst bt = inblossom[t];\n\t\t\t\tassert(label[bt] === 2);\n\t\t\t\t// Trace one step back.\n\t\t\t\tassert(labelend[bt] >= 0);\n\t\t\t\ts = endpoint[labelend[bt]];\n\t\t\t\tconst j = endpoint[labelend[bt] ^ 1];\n\t\t\t\t// Augment through the T-blossom from j to base.\n\t\t\t\tassert(blossombase[bt] === t);\n\t\t\t\tif (bt >= nvertex) augmentBlossom(bt, j);\n\t\t\t\t// Update mate[j]\n\t\t\t\tmate[j] = labelend[bt];\n\t\t\t\t// Keep the opposite endpoint;\n\t\t\t\t// it will be assigned to mate[s] in the next step.\n\t\t\t\tp = labelend[bt] ^ 1;\n\t\t\t\tconsole.debug(\n\t\t\t\t\t'DEBUG: PAIR ' + s + ' ' + t + ' (k=' + Math.floor(p / 2) + ')',\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\n\t\tlet d;\n\t\tlet kslack;\n\t\tlet base;\n\t\tlet deltatype;\n\t\tlet delta;\n\t\tlet deltaedge;\n\t\tlet deltablossom;\n\n\t\t// Main loop: continue until no further improvement is possible.\n\t\tfor (let t = 0; t < nvertex; ++t) {\n\t\t\t// Each iteration of this loop is a \"stage\".\n\t\t\t// A stage finds an augmenting path and uses that to improve\n\t\t\t// the matching.\n\t\t\tconsole.debug('DEBUG: STAGE ' + t);\n\n\t\t\t// Remove labels from top-level blossoms/vertices.\n\t\t\tlabel.fill(0);\n\n\t\t\t// Forget all about least-slack edges.\n\t\t\tbestedge.fill(-1);\n\t\t\tblossombestedges.fill(null, nvertex, 2 * nvertex);\n\n\t\t\t// Loss of labeling means that we can not be sure that currently\n\t\t\t// allowable edges remain allowable througout this stage.\n\t\t\tallowedge.fill(false);\n\n\t\t\t// Make queue empty.\n\t\t\tqueue = [];\n\n\t\t\t// Label single blossoms/vertices with S and put them in the queue.\n\t\t\tfor (let v = 0; v < nvertex; ++v) {\n\t\t\t\tif (mate[v] === -1 && label[inblossom[v]] === 0) assignLabel(v, 1, -1);\n\t\t\t}\n\n\t\t\t// Loop until we succeed in augmenting the matching.\n\t\t\tlet augmented = false;\n\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t\twhile (true) {\n\t\t\t\t// Each iteration of this loop is a \"substage\".\n\t\t\t\t// A substage tries to find an augmenting path;\n\t\t\t\t// if found, the path is used to improve the matching and\n\t\t\t\t// the stage ends. If there is no augmenting path, the\n\t\t\t\t// primal-dual method is used to pump some slack out of\n\t\t\t\t// the dual variables.\n\t\t\t\tconsole.debug('DEBUG: SUBSTAGE');\n\n\t\t\t\t// Continue labeling until all vertices which are reachable\n\t\t\t\t// through an alternating path have got a label.\n\t\t\t\twhile (queue.length > 0 && !augmented) {\n\t\t\t\t\t// Take an S vertex from the queue.\n\t\t\t\t\tconst v = queue.pop();\n\t\t\t\t\tconsole.debug('DEBUG: POP v=' + v);\n\t\t\t\t\tassert(label[inblossom[v]] === 1);\n\n\t\t\t\t\t// Scan its neighbours:\n\t\t\t\t\tconst length = neighbend[v].length;\n\t\t\t\t\tfor (let i = 0; i < length; ++i) {\n\t\t\t\t\t\tconst p = neighbend[v][i];\n\t\t\t\t\t\tconst k = Math.floor(p / 2);\n\t\t\t\t\t\tconst w = endpoint[p];\n\t\t\t\t\t\t// W is a neighbour to v\n\t\t\t\t\t\tif (inblossom[v] === inblossom[w]) {\n\t\t\t\t\t\t\t// This edge is internal to a blossom; ignore it\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!allowedge[k]) {\n\t\t\t\t\t\t\tkslack = slack(k);\n\t\t\t\t\t\t\tif (kslack <= 0) {\n\t\t\t\t\t\t\t\t// Edge k has zero slack => it is allowable\n\t\t\t\t\t\t\t\tallowedge[k] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (allowedge[k]) {\n\t\t\t\t\t\t\tif (label[inblossom[w]] === 0) {\n\t\t\t\t\t\t\t\t// (C1) w is a free vertex;\n\t\t\t\t\t\t\t\t// label w with T and label its mate with S (R12).\n\t\t\t\t\t\t\t\tassignLabel(w, 2, p ^ 1);\n\t\t\t\t\t\t\t} else if (label[inblossom[w]] === 1) {\n\t\t\t\t\t\t\t\t// (C2) w is an S-vertex (not in the same blossom);\n\t\t\t\t\t\t\t\t// follow back-links to discover either an\n\t\t\t\t\t\t\t\t// augmenting path or a new blossom.\n\t\t\t\t\t\t\t\tbase = scanBlossom(v, w);\n\t\t\t\t\t\t\t\tif (base >= 0) {\n\t\t\t\t\t\t\t\t\t// Found a new blossom; add it to the blossom\n\t\t\t\t\t\t\t\t\t// bookkeeping and turn it into an S-blossom.\n\t\t\t\t\t\t\t\t\taddBlossom(base, k);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Found an augmenting path; augment the\n\t\t\t\t\t\t\t\t\t// matching and end this stage.\n\t\t\t\t\t\t\t\t\taugmentMatching(k);\n\t\t\t\t\t\t\t\t\taugmented = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (label[w] === 0) {\n\t\t\t\t\t\t\t\t// W is inside a T-blossom, but w itthis has not\n\t\t\t\t\t\t\t\t// yet been reached from outside the blossom;\n\t\t\t\t\t\t\t\t// mark it as reached (we need this to relabel\n\t\t\t\t\t\t\t\t// during T-blossom expansion).\n\t\t\t\t\t\t\t\tassert(label[inblossom[w]] === 2);\n\t\t\t\t\t\t\t\tlabel[w] = 2;\n\t\t\t\t\t\t\t\tlabelend[w] = p ^ 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (label[inblossom[w]] === 1) {\n\t\t\t\t\t\t\t// Keep track of the least-slack non-allowable edge to\n\t\t\t\t\t\t\t// a different S-blossom.\n\t\t\t\t\t\t\tconst b = inblossom[v];\n\t\t\t\t\t\t\tif (bestedge[b] === -1 || kslack < slack(bestedge[b]))\n\t\t\t\t\t\t\t\tbestedge[b] = k;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tlabel[w] === 0 && // W is a free vertex (or an unreached vertex inside\n\t\t\t\t\t\t\t// a T-blossom) but we can not reach it yet;\n\t\t\t\t\t\t\t// keep track of the least-slack edge that reaches w.\n\t\t\t\t\t\t\t(bestedge[w] === -1 || kslack < slack(bestedge[w]))\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\tbestedge[w] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (augmented) break;\n\n\t\t\t\t// There is no augmenting path under these constraints;\n\t\t\t\t// compute delta and reduce slack in the optimization problem.\n\t\t\t\t// (Note that our vertex dual variables, edge slacks and delta's\n\t\t\t\t// are pre-multiplied by two.)\n\t\t\t\tdeltatype = -1;\n\t\t\t\tdelta = null;\n\t\t\t\tdeltaedge = null;\n\t\t\t\tdeltablossom = null;\n\n\t\t\t\t// Verify data structures for delta2/delta3 computation.\n\t\t\t\tif (CHECK_DELTA) {\n\t\t\t\t\tcheckDelta2({\n\t\t\t\t\t\tnvertex,\n\t\t\t\t\t\tneighbend,\n\t\t\t\t\t\tlabel,\n\t\t\t\t\t\tendpoint,\n\t\t\t\t\t\tbestedge,\n\t\t\t\t\t\tslack,\n\t\t\t\t\t\tinblossom,\n\t\t\t\t\t});\n\t\t\t\t\tcheckDelta3({\n\t\t\t\t\t\tnvertex,\n\t\t\t\t\t\tedges,\n\t\t\t\t\t\tblossomparent,\n\t\t\t\t\t\tblossomchilds,\n\t\t\t\t\t\tneighbend,\n\t\t\t\t\t\tlabel,\n\t\t\t\t\t\tendpoint,\n\t\t\t\t\t\tbestedge,\n\t\t\t\t\t\tslack,\n\t\t\t\t\t\tinblossom,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Compute delta1: the minumum value of any vertex dual.\n\t\t\t\tif (!maxCardinality) {\n\t\t\t\t\tdeltatype = 1;\n\t\t\t\t\tdelta = min(dualvar, 0, nvertex);\n\t\t\t\t}\n\n\t\t\t\t// Compute delta2: the minimum slack on any edge between\n\t\t\t\t// an S-vertex and a free vertex.\n\t\t\t\tfor (let v = 0; v < nvertex; ++v) {\n\t\t\t\t\tif (label[inblossom[v]] === 0 && bestedge[v] !== -1) {\n\t\t\t\t\t\td = slack(bestedge[v]);\n\t\t\t\t\t\tif (deltatype === -1 || d < delta) {\n\t\t\t\t\t\t\tdelta = d;\n\t\t\t\t\t\t\tdeltatype = 2;\n\t\t\t\t\t\t\tdeltaedge = bestedge[v];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Compute delta3: half the minimum slack on any edge between\n\t\t\t\t// a pair of S-blossoms.\n\t\t\t\tfor (let b = 0; b < 2 * nvertex; ++b) {\n\t\t\t\t\tif (blossomparent[b] === -1 && label[b] === 1 && bestedge[b] !== -1) {\n\t\t\t\t\t\tkslack = slack(bestedge[b]);\n\t\t\t\t\t\td = kslack / 2;\n\t\t\t\t\t\tif (deltatype === -1 || d < delta) {\n\t\t\t\t\t\t\tdelta = d;\n\t\t\t\t\t\t\tdeltatype = 3;\n\t\t\t\t\t\t\tdeltaedge = bestedge[b];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Compute delta4: minimum z variable of any T-blossom.\n\t\t\t\tfor (let b = nvertex; b < 2 * nvertex; ++b) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tblossombase[b] >= 0 &&\n\t\t\t\t\t\tblossomparent[b] === -1 &&\n\t\t\t\t\t\tlabel[b] === 2 &&\n\t\t\t\t\t\t(deltatype === -1 || dualvar[b] < delta)\n\t\t\t\t\t) {\n\t\t\t\t\t\tdelta = dualvar[b];\n\t\t\t\t\t\tdeltatype = 4;\n\t\t\t\t\t\tdeltablossom = b;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (deltatype === -1) {\n\t\t\t\t\t// No further improvement possible; max-cardinality optimum\n\t\t\t\t\t// reached. Do a final delta update to make the optimum\n\t\t\t\t\t// verifyable.\n\t\t\t\t\tassert(maxCardinality);\n\t\t\t\t\tdeltatype = 1;\n\t\t\t\t\tdelta = Math.max(0, min(dualvar, 0, nvertex));\n\t\t\t\t}\n\n\t\t\t\t// Update dual variables according to delta.\n\t\t\t\tfor (let v = 0; v < nvertex; ++v) {\n\t\t\t\t\tif (label[inblossom[v]] === 1) {\n\t\t\t\t\t\t// S-vertex: 2*u = 2*u - 2*delta\n\t\t\t\t\t\tdualvar[v] -= delta;\n\t\t\t\t\t} else if (label[inblossom[v]] === 2) {\n\t\t\t\t\t\t// T-vertex: 2*u = 2*u + 2*delta\n\t\t\t\t\t\tdualvar[v] += delta;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (let b = nvertex; b < 2 * nvertex; ++b) {\n\t\t\t\t\tif (blossombase[b] >= 0 && blossomparent[b] === -1) {\n\t\t\t\t\t\tif (label[b] === 1) {\n\t\t\t\t\t\t\t// Top-level S-blossom: z = z + 2*delta\n\t\t\t\t\t\t\tdualvar[b] += delta;\n\t\t\t\t\t\t} else if (label[b] === 2) {\n\t\t\t\t\t\t\t// Top-level T-blossom: z = z - 2*delta\n\t\t\t\t\t\t\tdualvar[b] -= delta;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Take action at the point where minimum delta occurred.\n\t\t\t\tconsole.debug('DEBUG: delta' + deltatype + '=' + delta);\n\t\t\t\tassert(\n\t\t\t\t\tdeltatype === 1 ||\n\t\t\t\t\t\tdeltatype === 2 ||\n\t\t\t\t\t\tdeltatype === 3 ||\n\t\t\t\t\t\tdeltatype === 4,\n\t\t\t\t);\n\t\t\t\tif (deltatype === 1) {\n\t\t\t\t\t// No further improvement possible; optimum reached.\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (deltatype === 2) {\n\t\t\t\t\t// Use the least-slack edge to continue the search.\n\t\t\t\t\tallowedge[deltaedge] = true;\n\t\t\t\t\tlet i = edges[deltaedge][0];\n\t\t\t\t\tif (label[inblossom[i]] === 0) i = edges[deltaedge][1];\n\t\t\t\t\tassert(label[inblossom[i]] === 1);\n\t\t\t\t\tqueue.push(i);\n\t\t\t\t} else if (deltatype === 3) {\n\t\t\t\t\t// Use the least-slack edge to continue the search.\n\t\t\t\t\tallowedge[deltaedge] = true;\n\t\t\t\t\tconst i = edges[deltaedge][0];\n\t\t\t\t\tassert(label[inblossom[i]] === 1);\n\t\t\t\t\tqueue.push(i);\n\t\t\t\t} else {\n\t\t\t\t\t// Expand the least-z blossom.\n\t\t\t\t\texpandBlossom(deltablossom, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// End of a this substage.\n\n\t\t\t// Stop when no more augmenting path can be found.\n\t\t\tif (!augmented) break;\n\n\t\t\t// End of a stage; expand all S-blossoms which have dualvar = 0.\n\t\t\tfor (let b = nvertex; b < 2 * nvertex; ++b) {\n\t\t\t\tif (\n\t\t\t\t\tblossomparent[b] === -1 &&\n\t\t\t\t\tblossombase[b] >= 0 &&\n\t\t\t\t\tlabel[b] === 1 &&\n\t\t\t\t\tdualvar[b] === 0\n\t\t\t\t) {\n\t\t\t\t\texpandBlossom(b, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Verify that we reached the optimum solution.\n\t\tif (CHECK_OPTIMUM)\n\t\t\tverifyOptimum({\n\t\t\t\tnvertex,\n\t\t\t\tedges,\n\t\t\t\tmaxCardinality,\n\t\t\t\tnedge,\n\t\t\t\tblossomparent,\n\t\t\t\tmate,\n\t\t\t\tendpoint,\n\t\t\t\tdualvar,\n\t\t\t\tblossombase,\n\t\t\t\tblossomendps,\n\t\t\t});\n\n\t\t// Transform mate[] such that mate[v] is the vertex to which v is paired.\n\t\tfor (let v = 0; v < nvertex; ++v) {\n\t\t\tif (mate[v] >= 0) {\n\t\t\t\tmate[v] = endpoint[mate[v]];\n\t\t\t}\n\t\t}\n\n\t\tfor (let v = 0; v < nvertex; ++v) {\n\t\t\tassert(mate[v] === -1 || mate[mate[v]] === v);\n\t\t}\n\n\t\treturn mate;\n\t};\n\n\treturn maxWeightMatching;\n}\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/core/blossom/blossom.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 60,
    "kind": "function",
    "name": "blossom",
    "memberof": "src/core/blossom/blossom.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/blossom/blossom.js~blossom",
    "access": "public",
    "export": true,
    "importPath": "@graph-algorithm/maximum-matching/src/core/blossom/blossom.js",
    "importStyle": "blossom",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "params": [
      {
        "name": "CHECK_OPTIMUM",
        "types": [
          "*"
        ]
      },
      {
        "name": "CHECK_DELTA",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 61,
    "kind": "file",
    "name": "src/core/blossom/blossomEdges.js",
    "content": "import blossomLeaves from './blossomLeaves.js';\n\nexport default function* blossomEdges(nvertex, blossomchilds, neighbend, bv) {\n\tfor (const v of blossomLeaves(nvertex, blossomchilds, bv)) {\n\t\tfor (const p of neighbend[v]) yield Math.floor(p / 2);\n\t}\n}\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/core/blossom/blossomEdges.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 62,
    "kind": "function",
    "name": "blossomEdges",
    "memberof": "src/core/blossom/blossomEdges.js",
    "generator": true,
    "async": false,
    "static": true,
    "longname": "src/core/blossom/blossomEdges.js~blossomEdges",
    "access": "public",
    "export": true,
    "importPath": "@graph-algorithm/maximum-matching/src/core/blossom/blossomEdges.js",
    "importStyle": "blossomEdges",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "nvertex",
        "types": [
          "*"
        ]
      },
      {
        "name": "blossomchilds",
        "types": [
          "*"
        ]
      },
      {
        "name": "neighbend",
        "types": [
          "*"
        ]
      },
      {
        "name": "bv",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 63,
    "kind": "file",
    "name": "src/core/blossom/blossomLeaves.js",
    "content": "/**\n * Generate the leaf vertices of a blossom via depth-first search.\n */\nexport default function* blossomLeaves(nvertex, nodes, b) {\n\tif (b < nvertex) yield b;\n\telse yield* _blossomLeavesDFS(nvertex, nodes, nodes[b].slice());\n}\n\nfunction* _blossomLeavesDFS(nvertex, nodes, queue) {\n\twhile (queue.length > 0) {\n\t\tconst b = queue.pop();\n\t\tif (b < nvertex) yield b;\n\t\telse for (const t of nodes[b]) queue.push(t);\n\t}\n}\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/core/blossom/blossomLeaves.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 64,
    "kind": "function",
    "name": "blossomLeaves",
    "memberof": "src/core/blossom/blossomLeaves.js",
    "generator": true,
    "async": false,
    "static": true,
    "longname": "src/core/blossom/blossomLeaves.js~blossomLeaves",
    "access": "public",
    "export": true,
    "importPath": "@graph-algorithm/maximum-matching/src/core/blossom/blossomLeaves.js",
    "importStyle": "blossomLeaves",
    "description": "Generate the leaf vertices of a blossom via depth-first search.",
    "lineNumber": 4,
    "params": [
      {
        "name": "nvertex",
        "types": [
          "*"
        ]
      },
      {
        "name": "nodes",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 65,
    "kind": "function",
    "name": "_blossomLeavesDFS",
    "memberof": "src/core/blossom/blossomLeaves.js",
    "generator": true,
    "async": false,
    "static": true,
    "longname": "src/core/blossom/blossomLeaves.js~_blossomLeavesDFS",
    "access": "private",
    "export": false,
    "importPath": "@graph-algorithm/maximum-matching/src/core/blossom/blossomLeaves.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "params": [
      {
        "name": "nvertex",
        "types": [
          "*"
        ]
      },
      {
        "name": "nodes",
        "types": [
          "*"
        ]
      },
      {
        "name": "queue",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 66,
    "kind": "file",
    "name": "src/core/blossom/checkDelta2.js",
    "content": "import assert from 'assert';\n\n// Check optimized delta2 against a trivial computation.\nconst checkDelta2 = ({\n\tnvertex,\n\tneighbend,\n\tlabel,\n\tendpoint,\n\tbestedge,\n\tslack,\n\tinblossom,\n}) => {\n\tfor (let v = 0; v < nvertex; ++v) {\n\t\tif (label[inblossom[v]] === 0) {\n\t\t\tlet bd = null;\n\t\t\tlet bk = -1;\n\t\t\tfor (let i = 0; i < neighbend[v].length; ++i) {\n\t\t\t\tconst p = neighbend[v][i];\n\t\t\t\tconst k = Math.floor(p / 2);\n\t\t\t\tconst w = endpoint[p];\n\t\t\t\tif (label[inblossom[w]] === 1) {\n\t\t\t\t\tconst d = slack(k);\n\t\t\t\t\tif (bk === -1 || d < bd) {\n\t\t\t\t\t\tbk = k;\n\t\t\t\t\t\tbd = d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t(bestedge[v] !== -1 || bk !== -1) &&\n\t\t\t\t(bestedge[v] === -1 || bd !== slack(bestedge[v]))\n\t\t\t) {\n\t\t\t\tconsole.debug(\n\t\t\t\t\t'v=' +\n\t\t\t\t\t\tv +\n\t\t\t\t\t\t' bk=' +\n\t\t\t\t\t\tbk +\n\t\t\t\t\t\t' bd=' +\n\t\t\t\t\t\tbd +\n\t\t\t\t\t\t' bestedge=' +\n\t\t\t\t\t\tbestedge[v] +\n\t\t\t\t\t\t' slack=' +\n\t\t\t\t\t\tslack(bestedge[v]),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tassert(\n\t\t\t\t(bk === -1 && bestedge[v] === -1) ||\n\t\t\t\t\t(bestedge[v] !== -1 && bd === slack(bestedge[v])),\n\t\t\t);\n\t\t}\n\t}\n};\n\nexport default checkDelta2;\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/core/blossom/checkDelta2.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 67,
    "kind": "function",
    "name": "checkDelta2",
    "memberof": "src/core/blossom/checkDelta2.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/blossom/checkDelta2.js~checkDelta2",
    "access": "public",
    "export": true,
    "importPath": "@graph-algorithm/maximum-matching/src/core/blossom/checkDelta2.js",
    "importStyle": "checkDelta2",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"nvertex\": *, \"neighbend\": *, \"label\": *, \"endpoint\": *, \"bestedge\": *, \"slack\": *, \"inblossom\": *}"
        ],
        "defaultRaw": {
          "nvertex": null,
          "neighbend": null,
          "label": null,
          "endpoint": null,
          "bestedge": null,
          "slack": null,
          "inblossom": null
        },
        "defaultValue": "{\"nvertex\":null,\"neighbend\":null,\"label\":null,\"endpoint\":null,\"bestedge\":null,\"slack\":null,\"inblossom\":null}"
      }
    ],
    "return": null
  },
  {
    "__docId__": 68,
    "kind": "file",
    "name": "src/core/blossom/checkDelta3.js",
    "content": "import assert from 'assert';\nimport blossomLeaves from './blossomLeaves.js';\n\n// Check optimized delta3 against a trivial computation.\nconst checkDelta3 = ({\n\tnvertex,\n\tedges,\n\tblossomparent,\n\tblossomchilds,\n\tneighbend,\n\tlabel,\n\tendpoint,\n\tbestedge,\n\tslack,\n\tinblossom,\n}) => {\n\tlet bk = -1;\n\tlet bd = null;\n\tlet tbk = -1;\n\tlet tbd = null;\n\tfor (let b = 0; b < 2 * nvertex; ++b) {\n\t\tif (blossomparent[b] === -1 && label[b] === 1) {\n\t\t\tfor (const v of blossomLeaves(nvertex, blossomchilds, b)) {\n\t\t\t\tfor (const p of neighbend[v]) {\n\t\t\t\t\tconst k = Math.floor(p / 2);\n\t\t\t\t\tconst w = endpoint[p];\n\t\t\t\t\tif (inblossom[w] !== b && label[inblossom[w]] === 1) {\n\t\t\t\t\t\tconst d = slack(k);\n\t\t\t\t\t\tif (bk === -1 || d < bd) {\n\t\t\t\t\t\t\tbk = k;\n\t\t\t\t\t\t\tbd = d;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bestedge[b] !== -1) {\n\t\t\t\tconst i = edges[bestedge[b]][0];\n\t\t\t\tconst j = edges[bestedge[b]][1];\n\n\t\t\t\tassert(inblossom[i] === b || inblossom[j] === b);\n\t\t\t\tassert(inblossom[i] !== b || inblossom[j] !== b);\n\t\t\t\tassert(label[inblossom[i]] === 1 && label[inblossom[j]] === 1);\n\t\t\t\tif (tbk === -1 || slack(bestedge[b]) < tbd) {\n\t\t\t\t\ttbk = bestedge[b];\n\t\t\t\t\ttbd = slack(bestedge[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bd !== tbd)\n\t\tconsole.debug('bk=' + bk + ' tbk=' + tbk + ' bd=' + bd + ' tbd=' + tbd);\n\tassert(bd === tbd);\n};\n\nexport default checkDelta3;\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/core/blossom/checkDelta3.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 69,
    "kind": "function",
    "name": "checkDelta3",
    "memberof": "src/core/blossom/checkDelta3.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/blossom/checkDelta3.js~checkDelta3",
    "access": "public",
    "export": true,
    "importPath": "@graph-algorithm/maximum-matching/src/core/blossom/checkDelta3.js",
    "importStyle": "checkDelta3",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"nvertex\": *, \"edges\": *, \"blossomparent\": *, \"blossomchilds\": *, \"neighbend\": *, \"label\": *, \"endpoint\": *, \"bestedge\": *, \"slack\": *, \"inblossom\": *}"
        ],
        "defaultRaw": {
          "nvertex": null,
          "edges": null,
          "blossomparent": null,
          "blossomchilds": null,
          "neighbend": null,
          "label": null,
          "endpoint": null,
          "bestedge": null,
          "slack": null,
          "inblossom": null
        },
        "defaultValue": "{\"nvertex\":null,\"edges\":null,\"blossomparent\":null,\"blossomchilds\":null,\"neighbend\":null,\"label\":null,\"endpoint\":null,\"bestedge\":null,\"slack\":null,\"inblossom\":null}"
      }
    ],
    "return": null
  },
  {
    "__docId__": 70,
    "kind": "file",
    "name": "src/core/blossom/endpoints.js",
    "content": "const endpoints = (nedge, edges) => {\n\tconst endpoint = [];\n\tfor (let p = 0; p < nedge; ++p) {\n\t\tendpoint.push(edges[p][0], edges[p][1]);\n\t}\n\n\treturn endpoint;\n};\n\nexport default endpoints;\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/core/blossom/endpoints.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 71,
    "kind": "function",
    "name": "endpoints",
    "memberof": "src/core/blossom/endpoints.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/blossom/endpoints.js~endpoints",
    "access": "public",
    "export": true,
    "importPath": "@graph-algorithm/maximum-matching/src/core/blossom/endpoints.js",
    "importStyle": "endpoints",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "params": [
      {
        "name": "nedge",
        "types": [
          "*"
        ]
      },
      {
        "name": "edges",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "file",
    "name": "src/core/blossom/index.js",
    "content": "import blossom from './blossom.js';\nimport checkDelta2 from './checkDelta2.js';\nimport checkDelta3 from './checkDelta3.js';\nimport min from './min.js';\nimport rotate from './rotate.js';\nimport verifyOptimum from './verifyOptimum.js';\n\nexport default blossom;\n\nexport {blossom, checkDelta2, checkDelta3, min, rotate, verifyOptimum};\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/core/blossom/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 73,
    "kind": "file",
    "name": "src/core/blossom/min.js",
    "content": "const min = (a, i, j) => {\n\tlet o = a[i];\n\tfor (++i; i < j; ++i) if (a[i] < o) o = a[i];\n\treturn o;\n};\n\nexport default min;\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/core/blossom/min.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 74,
    "kind": "function",
    "name": "min",
    "memberof": "src/core/blossom/min.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/blossom/min.js~min",
    "access": "public",
    "export": true,
    "importPath": "@graph-algorithm/maximum-matching/src/core/blossom/min.js",
    "importStyle": "min",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "i",
        "types": [
          "*"
        ]
      },
      {
        "name": "j",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 75,
    "kind": "file",
    "name": "src/core/blossom/neighbours.js",
    "content": "const neighbours = (nvertex, nedge, edges) => {\n\tconst neighbend = [];\n\n\tfor (let i = 0; i < nvertex; ++i) neighbend.push([]);\n\n\tfor (let k = 0; k < nedge; ++k) {\n\t\tconst i = edges[k][0];\n\t\tconst j = edges[k][1];\n\t\tneighbend[i].push(2 * k + 1);\n\t\tneighbend[j].push(2 * k);\n\t}\n\n\treturn neighbend;\n};\n\nexport default neighbours;\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/core/blossom/neighbours.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 76,
    "kind": "function",
    "name": "neighbours",
    "memberof": "src/core/blossom/neighbours.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/blossom/neighbours.js~neighbours",
    "access": "public",
    "export": true,
    "importPath": "@graph-algorithm/maximum-matching/src/core/blossom/neighbours.js",
    "importStyle": "neighbours",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "params": [
      {
        "name": "nvertex",
        "types": [
          "*"
        ]
      },
      {
        "name": "nedge",
        "types": [
          "*"
        ]
      },
      {
        "name": "edges",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 77,
    "kind": "file",
    "name": "src/core/blossom/rotate.js",
    "content": "const rotate = (a, n) => {\n\tconst head = a.splice(0, n);\n\tfor (let i = 0; i < n; ++i) {\n\t\ta.push(head[i]);\n\t}\n};\n\nexport default rotate;\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/core/blossom/rotate.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 78,
    "kind": "function",
    "name": "rotate",
    "memberof": "src/core/blossom/rotate.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/blossom/rotate.js~rotate",
    "access": "public",
    "export": true,
    "importPath": "@graph-algorithm/maximum-matching/src/core/blossom/rotate.js",
    "importStyle": "rotate",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "n",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 79,
    "kind": "file",
    "name": "src/core/blossom/statistics.js",
    "content": "import assert from 'assert';\n\nconst statistics = (edges) => {\n\tconst nedge = edges.length;\n\tlet nvertex = 0;\n\tlet maxweight = 0;\n\n\tlet length = nedge;\n\twhile (length--) {\n\t\tconst i = edges[length][0];\n\t\tconst j = edges[length][1];\n\t\tconst w = edges[length][2];\n\n\t\tassert(i >= 0 && j >= 0 && i !== j);\n\t\tif (i >= nvertex) nvertex = i + 1;\n\t\tif (j >= nvertex) nvertex = j + 1;\n\n\t\tmaxweight = Math.max(maxweight, w);\n\t}\n\n\treturn [nvertex, nedge, maxweight];\n};\n\nexport default statistics;\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/core/blossom/statistics.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 80,
    "kind": "function",
    "name": "statistics",
    "memberof": "src/core/blossom/statistics.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/blossom/statistics.js~statistics",
    "access": "public",
    "export": true,
    "importPath": "@graph-algorithm/maximum-matching/src/core/blossom/statistics.js",
    "importStyle": "statistics",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "edges",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "file",
    "name": "src/core/blossom/verifyOptimum.js",
    "content": "import assert from 'assert';\nimport min from './min.js';\n\n// Verify that the optimum solution has been reached.\nconst verifyOptimum = ({\n\tnvertex,\n\tedges,\n\tmaxCardinality,\n\tnedge,\n\tblossomparent,\n\tmate,\n\tendpoint,\n\tdualvar,\n\tblossombase,\n\tblossomendps,\n}) => {\n\tlet i;\n\tlet j;\n\tlet wt;\n\tlet v;\n\tlet b;\n\tlet p;\n\tlet k;\n\tlet s;\n\tlet iblossoms;\n\tlet jblossoms;\n\t// Vertices may have negative dual when maxCardinality = true;\n\t// find a constant non-negative number to add to all vertex duals.\n\tconst vdualoffset = maxCardinality\n\t\t? Math.max(0, -min(dualvar, 0, nvertex))\n\t\t: 0;\n\t// 0. all dual variables are non-negative\n\tassert(min(dualvar, 0, nvertex) + vdualoffset >= 0);\n\tassert(min(dualvar, nvertex, 2 * nvertex) >= 0);\n\t// 0. all edges have non-negative slack and\n\t// 1. all matched edges have zero slack;\n\tfor (k = 0; k < nedge; ++k) {\n\t\ti = edges[k][0];\n\t\tj = edges[k][1];\n\t\twt = edges[k][2];\n\n\t\ts = dualvar[i] + dualvar[j] - 2 * wt;\n\t\tiblossoms = [i];\n\t\tjblossoms = [j];\n\t\twhile (blossomparent[iblossoms[iblossoms.length - 1]] !== -1)\n\t\t\tiblossoms.push(blossomparent[iblossoms[iblossoms.length - 1]]);\n\t\twhile (blossomparent[jblossoms[jblossoms.length - 1]] !== -1)\n\t\t\tjblossoms.push(blossomparent[jblossoms[jblossoms.length - 1]]);\n\t\tiblossoms.reverse();\n\t\tjblossoms.reverse();\n\t\tconst length = Math.min(iblossoms.length, jblossoms.length);\n\t\tfor (let x = 0; x < length; ++x) {\n\t\t\tconst bi = iblossoms[x];\n\t\t\tconst bj = jblossoms[x];\n\t\t\tif (bi !== bj) break;\n\t\t\ts += 2 * dualvar[bi];\n\t\t}\n\n\t\tassert(s >= 0);\n\t\tif (Math.floor(mate[i] / 2) === k || Math.floor(mate[j] / 2) === k) {\n\t\t\tassert(Math.floor(mate[i] / 2) === k && Math.floor(mate[j] / 2) === k);\n\t\t\tassert(s === 0);\n\t\t}\n\t}\n\n\t// 2. all single vertices have zero dual value;\n\tfor (v = 0; v < nvertex; ++v)\n\t\tassert(mate[v] >= 0 || dualvar[v] + vdualoffset === 0);\n\t// 3. all blossoms with positive dual value are full.\n\tfor (b = nvertex; b < 2 * nvertex; ++b) {\n\t\tif (blossombase[b] >= 0 && dualvar[b] > 0) {\n\t\t\tassert(blossomendps[b].length % 2 === 1);\n\t\t\tfor (i = 1; i < blossomendps[b].length; i += 2) {\n\t\t\t\tp = blossomendps[b][i];\n\t\t\t\tassert((mate[endpoint[p]] === p) ^ 1);\n\t\t\t\tassert(mate[endpoint[p ^ 1]] === p);\n\t\t\t}\n\t\t}\n\t}\n\t// Ok.\n};\n\nexport default verifyOptimum;\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/core/blossom/verifyOptimum.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 82,
    "kind": "function",
    "name": "verifyOptimum",
    "memberof": "src/core/blossom/verifyOptimum.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core/blossom/verifyOptimum.js~verifyOptimum",
    "access": "public",
    "export": true,
    "importPath": "@graph-algorithm/maximum-matching/src/core/blossom/verifyOptimum.js",
    "importStyle": "verifyOptimum",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"nvertex\": *, \"edges\": *, \"maxCardinality\": *, \"nedge\": *, \"blossomparent\": *, \"mate\": *, \"endpoint\": *, \"dualvar\": *, \"blossombase\": *, \"blossomendps\": *}"
        ],
        "defaultRaw": {
          "nvertex": null,
          "edges": null,
          "maxCardinality": null,
          "nedge": null,
          "blossomparent": null,
          "mate": null,
          "endpoint": null,
          "dualvar": null,
          "blossombase": null,
          "blossomendps": null
        },
        "defaultValue": "{\"nvertex\":null,\"edges\":null,\"maxCardinality\":null,\"nedge\":null,\"blossomparent\":null,\"mate\":null,\"endpoint\":null,\"dualvar\":null,\"blossombase\":null,\"blossomendps\":null}"
      }
    ],
    "return": null
  },
  {
    "__docId__": 83,
    "kind": "file",
    "name": "src/core/blossomNoChecks.js",
    "content": "import blossom from './blossom/index.js';\n\nconst blossomNoChecks = blossom(false, false);\n\nexport default blossomNoChecks;\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/core/blossomNoChecks.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 84,
    "kind": "variable",
    "name": "blossomNoChecks",
    "memberof": "src/core/blossomNoChecks.js",
    "static": true,
    "longname": "src/core/blossomNoChecks.js~blossomNoChecks",
    "access": "public",
    "export": true,
    "importPath": "@graph-algorithm/maximum-matching/src/core/blossomNoChecks.js",
    "importStyle": "blossomNoChecks",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "file",
    "name": "src/core/index.js",
    "content": "import blossom from './blossom/index.js';\nimport blossomNoChecks from './blossomNoChecks.js';\n\n/* eslint import/no-anonymous-default-export: [2, {\"allowObject\": true}] */\nexport default {\n\tblossom,\n\tblossomNoChecks,\n};\n\nexport {blossom, blossomNoChecks};\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/core/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 86,
    "kind": "file",
    "name": "src/index.js",
    "content": "import cardinality from './cardinality/index.js';\nimport core from './core/index.js';\nimport weight from './weight/index.js';\nimport iter from './iter.js';\nimport addDefaultWeight from './addDefaultWeight.js';\n\nexport default weight;\n\nexport {cardinality, core, weight, iter, addDefaultWeight};\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 87,
    "kind": "file",
    "name": "src/iter.js",
    "content": "export default function* iter(matching) {\n\tlet i = 0;\n\tfor (const j of matching) {\n\t\t// This takes care of j === -1\n\t\tif (i < j) yield [i, j];\n\t\t++i;\n\t}\n}\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/iter.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 88,
    "kind": "function",
    "name": "iter",
    "memberof": "src/iter.js",
    "generator": true,
    "async": false,
    "static": true,
    "longname": "src/iter.js~iter",
    "access": "public",
    "export": true,
    "importPath": "@graph-algorithm/maximum-matching/src/iter.js",
    "importStyle": "iter",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "params": [
      {
        "name": "matching",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 89,
    "kind": "file",
    "name": "src/weight/approx/bipartite.js",
    "content": "import general from './general.js';\n\nexport default general;\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/weight/approx/bipartite.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 90,
    "kind": "file",
    "name": "src/weight/approx/general.js",
    "content": "import general from '../opt/general.js';\n\nconst generalApprox = (edges, _eps) => general(edges);\nexport default generalApprox;\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/weight/approx/general.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 91,
    "kind": "function",
    "name": "generalApprox",
    "memberof": "src/weight/approx/general.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/weight/approx/general.js~generalApprox",
    "access": "public",
    "export": true,
    "importPath": "@graph-algorithm/maximum-matching/src/weight/approx/general.js",
    "importStyle": "generalApprox",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "edges",
        "types": [
          "*"
        ]
      },
      {
        "name": "_eps",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 92,
    "kind": "file",
    "name": "src/weight/approx/index.js",
    "content": "import bipartite from './bipartite.js';\nimport general from './general.js';\n\nexport default general;\n\nexport {bipartite, general};\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/weight/approx/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 93,
    "kind": "file",
    "name": "src/weight/index.js",
    "content": "import approx from './approx/index.js';\nimport opt from './opt/index.js';\n\nexport default opt;\n\nexport {approx, opt};\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/weight/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 94,
    "kind": "file",
    "name": "src/weight/opt/bipartite.js",
    "content": "import general from './general.js';\n\nexport default general;\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/weight/opt/bipartite.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 95,
    "kind": "file",
    "name": "src/weight/opt/general.js",
    "content": "import blossomNoChecks from '../../core/blossomNoChecks.js';\n\nconst general = (edges) => blossomNoChecks(edges);\n\nexport default general;\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/weight/opt/general.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 96,
    "kind": "function",
    "name": "general",
    "memberof": "src/weight/opt/general.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/weight/opt/general.js~general",
    "access": "public",
    "export": true,
    "importPath": "@graph-algorithm/maximum-matching/src/weight/opt/general.js",
    "importStyle": "general",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "edges",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 97,
    "kind": "file",
    "name": "src/weight/opt/index.js",
    "content": "import bipartite from './bipartite.js';\nimport general from './general.js';\n\nexport default general;\n\nexport {bipartite, general};\n",
    "static": true,
    "longname": "/home/runner/work/maximum-matching/maximum-matching/src/weight/opt/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "kind": "index",
    "content": ":cherry_blossom: [@graph-algorithm/maximum-matching](https://graph-algorithm.github.io/maximum-matching)\n==\n\nMaximum matching algorithms for JavaScript.\nParent is [js-algorithms](https://github.com/make-github-pseudonymous-again/js-algorithms).\nSee [docs](https://graph-algorithm.github.io/maximum-matching/index.html).\n\n```js\nimport maximumMatching, {iter} from '@graph-algorithm/maximum-matching';\nconst edges = [[1, 2, 10], [2, 3, 11]] ;\nconst matching = maximumMatching(edges) ; // [-1, -1, 3, 2]\n[...iter(matching)]; // [ [2, 3] ]\n\nimport maximumCardinalityMatching from '@graph-algorithm/maximum-matching/cardinality';\nfor (const edge of iter(maximumCardinalityMatching([[1, 2], [2, 3], [3, 4]]))) {\n\tconsole.log(edge);\n}\n// [1,2]\n// [3,4]\n```\n\n[![License](https://img.shields.io/github/license/graph-algorithm/maximum-matching.svg)](https://raw.githubusercontent.com/graph-algorithm/maximum-matching/main/LICENSE)\n[![Version](https://img.shields.io/npm/v/@graph-algorithm/maximum-matching.svg)](https://www.npmjs.org/package/@graph-algorithm/maximum-matching)\n[![Tests](https://img.shields.io/github/workflow/status/graph-algorithm/maximum-matching/ci:test?event=push&label=tests)](https://github.com/graph-algorithm/maximum-matching/actions/workflows/ci:test.yml?query=branch:main)\n[![Dependencies](https://img.shields.io/david/graph-algorithm/maximum-matching.svg)](https://david-dm.org/graph-algorithm/maximum-matching)\n[![Dev dependencies](https://img.shields.io/david/dev/graph-algorithm/maximum-matching.svg)](https://david-dm.org/graph-algorithm/maximum-matching?type=dev)\n[![GitHub issues](https://img.shields.io/github/issues/graph-algorithm/maximum-matching.svg)](https://github.com/graph-algorithm/maximum-matching/issues)\n[![Downloads](https://img.shields.io/npm/dm/@graph-algorithm/maximum-matching.svg)](https://www.npmjs.org/package/@graph-algorithm/maximum-matching)\n\n[![Code issues](https://img.shields.io/codeclimate/issues/graph-algorithm/maximum-matching.svg)](https://codeclimate.com/github/graph-algorithm/maximum-matching/issues)\n[![Code maintainability](https://img.shields.io/codeclimate/maintainability/graph-algorithm/maximum-matching.svg)](https://codeclimate.com/github/graph-algorithm/maximum-matching/trends/churn)\n[![Code coverage (cov)](https://img.shields.io/codecov/c/gh/graph-algorithm/maximum-matching/main.svg)](https://codecov.io/gh/graph-algorithm/maximum-matching)\n[![Code technical debt](https://img.shields.io/codeclimate/tech-debt/graph-algorithm/maximum-matching.svg)](https://codeclimate.com/github/graph-algorithm/maximum-matching/trends/technical_debt)\n[![Documentation](https://graph-algorithm.github.io/maximum-matching/badge.svg)](https://graph-algorithm.github.io/maximum-matching/source.html)\n[![Package size](https://img.shields.io/bundlephobia/minzip/@graph-algorithm/maximum-matching)](https://bundlephobia.com/result?p=@graph-algorithm/maximum-matching)\n\n## :clap: Credits\n\nThe implementation of Edmond's *blossom* algorithm is adapted from\n[Joris van Rantwijk](http://jorisvr.nl)'s python\n[implementation](http://jorisvr.nl/article/maximum-matching)\n([python source](http://jorisvr.nl/files/graphmatching/20130407/mwmatching.py)).\nAll credit for the implementation goes to him and others that helped him.\n\nAnother adaptation by [Matt Krick](https://github.com/mattkrick)\ndistributed under the MIT license\nis available [here](https://github.com/mattkrick/EdmondsBlossom).\n",
    "longname": "/home/runner/work/maximum-matching/maximum-matching/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"@graph-algorithm/maximum-matching\",\n  \"description\": \"Maximum matching algorithms for JavaScript\",\n  \"version\": \"3.0.0\",\n  \"license\": \"AGPL-3.0\",\n  \"author\": \"make-github-pseudonymous-again\",\n  \"homepage\": \"https://graph-algorithm.github.io/maximum-matching\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/graph-algorithm/maximum-matching\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/graph-algorithm/maximum-matching/issues\"\n  },\n  \"keywords\": [\n    \"algorithm\",\n    \"graph\",\n    \"javascript\",\n    \"matching\",\n    \"maximum\"\n  ],\n  \"sideEffects\": false,\n  \"source\": \"src/index.js\",\n  \"main\": \"dist/default/index.js\",\n  \"module\": \"dist/module/index.js\",\n  \"esmodule\": \"dist/module/index.js\",\n  \"exports\": {\n    \".\": {\n      \"browser\": \"./dist/browser/index.js\",\n      \"node\": \"./dist/node/index.js\",\n      \"default\": \"./dist/default/index.js\"\n    },\n    \"./*\": {\n      \"browser\": \"./dist/browser/*.js\",\n      \"node\": \"./dist/node/*.js\",\n      \"default\": \"./dist/default/*.js\"\n    }\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"scripts\": {\n    \"build\": \"npm-run-all --parallel build:*\",\n    \"build-cmd\": \"babel --delete-dir-on-start --source-maps --minified src\",\n    \"build-docs\": \"esdoc\",\n    \"build-gh-pages\": \"npm run build-docs\",\n    \"build:browser\": \"npm run build-cmd -- --env-name browser --out-dir dist/browser\",\n    \"build:default\": \"npm run build-cmd -- --env-name production --out-dir dist/default\",\n    \"build:module\": \"npm run build-cmd -- --env-name module --out-dir dist/module\",\n    \"build:node\": \"npm run build-cmd -- --env-name node --out-dir dist/node\",\n    \"ci:test\": \"npm run lint-config && npm run lint && npm run cover\",\n    \"commit-msg\": \"commitlint --edit\",\n    \"cover\": \"NODE_ENV=cover c8 --all --src src --reporter lcov --reporter text-summary --reporter text npm test\",\n    \"debug\": \"NODE_ENV=debug npm run test -- -st --fail-fast\",\n    \"dev\": \"npm run lint-config-and-fix && npm run lint-and-fix && npm run cover -- -- -st --fail-fast\",\n    \"install-hooks\": \"husky install\",\n    \"lint\": \"xo\",\n    \"lint-and-fix\": \"npm run lint -- --fix\",\n    \"lint-config\": \"fixpack --dryRun\",\n    \"lint-config-and-fix\": \"fixpack || fixpack\",\n    \"postinstall\": \"npm run install-hooks\",\n    \"postpublish\": \"pinst --enable\",\n    \"precommit\": \"lint-staged\",\n    \"prepare\": \"npm run build\",\n    \"prepublishOnly\": \"pinst --disable\",\n    \"release\": \"np --message ':hatching_chick: release: Bumping to v%s.'\",\n    \"test\": \"ava\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"@babel/cli\": \"7.14.8\",\n    \"@babel/core\": \"7.14.8\",\n    \"@babel/preset-env\": \"7.14.8\",\n    \"@babel/register\": \"7.14.5\",\n    \"@commitlint/cli\": \"13.1.0\",\n    \"@iterable-iterator/zip\": \"^1.0.1\",\n    \"@js-library/commitlint-config\": \"0.0.4\",\n    \"ava\": \"3.15.0\",\n    \"babel-plugin-transform-remove-console\": \"6.9.4\",\n    \"babel-plugin-unassert\": \"3.1.0\",\n    \"babel-preset-minify\": \"0.5.1\",\n    \"babel-preset-power-assert\": \"3.0.0\",\n    \"c8\": \"7.7.3\",\n    \"coveralls\": \"3.1.1\",\n    \"esdoc\": \"1.1.0\",\n    \"esdoc-inject-script-plugin\": \"1.0.0\",\n    \"esdoc-inject-style-plugin\": \"1.0.0\",\n    \"esdoc-standard-plugin\": \"1.0.0\",\n    \"fixpack\": \"4.0.0\",\n    \"husky\": \"7.0.1\",\n    \"lint-staged\": \"11.1.1\",\n    \"np\": \"7.5.0\",\n    \"npm-run-all\": \"4.1.5\",\n    \"pinst\": \"2.1.6\",\n    \"power-assert\": \"1.6.1\",\n    \"regenerator-runtime\": \"0.13.9\",\n    \"xo\": \"0.38.2\"\n  },\n  \"ava\": {\n    \"files\": [\n      \"test/src/**/*\"\n    ],\n    \"require\": [\n      \"regenerator-runtime/runtime\",\n      \"@babel/register\"\n    ],\n    \"timeout\": \"1m\"\n  },\n  \"babel\": {\n    \"sourceMaps\": true,\n    \"presets\": [\n      [\n        \"@babel/preset-env\",\n        {\n          \"targets\": \"current node\"\n        }\n      ]\n    ],\n    \"plugins\": [\n      [\n        \"transform-remove-console\",\n        {\n          \"exclude\": [\n            \"log\",\n            \"error\",\n            \"warn\"\n          ]\n        }\n      ]\n    ],\n    \"env\": {\n      \"debug\": {\n        \"presets\": [\n          \"babel-preset-power-assert\"\n        ],\n        \"plugins\": [\n          [\n            \"transform-remove-console\",\n            {\n              \"exclude\": [\n                \"debug\",\n                \"log\",\n                \"error\",\n                \"warn\"\n              ]\n            }\n          ]\n        ]\n      },\n      \"test\": {\n        \"presets\": [\n          \"babel-preset-power-assert\"\n        ]\n      },\n      \"cover\": {\n        \"sourceMaps\": \"both\",\n        \"presets\": [\n          \"babel-preset-power-assert\"\n        ]\n      },\n      \"development\": {\n        \"presets\": [\n          [\n            \"@babel/preset-env\",\n            {\n              \"targets\": [\n                \"defaults\",\n                \"maintained node versions\"\n              ]\n            }\n          ],\n          \"babel-preset-power-assert\"\n        ]\n      },\n      \"production\": {\n        \"presets\": [\n          [\n            \"@babel/preset-env\",\n            {\n              \"targets\": [\n                \"defaults\",\n                \"maintained node versions\"\n              ]\n            }\n          ],\n          [\n            \"minify\",\n            {\n              \"builtIns\": false\n            }\n          ]\n        ],\n        \"plugins\": [\n          \"babel-plugin-unassert\"\n        ]\n      },\n      \"browser\": {\n        \"presets\": [\n          [\n            \"@babel/preset-env\",\n            {\n              \"targets\": [\n                \"defaults\"\n              ]\n            }\n          ],\n          [\n            \"minify\",\n            {\n              \"builtIns\": false\n            }\n          ]\n        ],\n        \"plugins\": [\n          \"babel-plugin-unassert\"\n        ]\n      },\n      \"node\": {\n        \"presets\": [\n          [\n            \"@babel/preset-env\",\n            {\n              \"targets\": [\n                \"maintained node versions\"\n              ]\n            }\n          ],\n          [\n            \"minify\",\n            {\n              \"builtIns\": false\n            }\n          ]\n        ],\n        \"plugins\": [\n          \"babel-plugin-unassert\"\n        ]\n      },\n      \"module\": {\n        \"presets\": [\n          [\n            \"@babel/preset-env\",\n            {\n              \"bugfixes\": true,\n              \"modules\": false,\n              \"targets\": {\n                \"esmodules\": true\n              }\n            }\n          ],\n          [\n            \"minify\",\n            {\n              \"builtIns\": false\n            }\n          ]\n        ],\n        \"plugins\": [\n          \"babel-plugin-unassert\"\n        ]\n      }\n    }\n  },\n  \"lint-staged\": {\n    \"*.js\": [\n      \"npm run lint-and-fix\"\n    ],\n    \"package.json\": [\n      \"npm run lint-config-and-fix\"\n    ]\n  },\n  \"prettier\": {\n    \"trailingComma\": \"all\"\n  },\n  \"xo\": {\n    \"prettier\": true,\n    \"rules\": {\n      \"camelcase\": \"off\",\n      \"unicorn/filename-case\": [\n        \"error\",\n        {\n          \"case\": \"camelCase\"\n        }\n      ],\n      \"unicorn/no-new-array\": \"off\"\n    },\n    \"overrides\": [\n      {\n        \"files\": [\n          \"doc/**\"\n        ],\n        \"env\": \"browser\"\n      }\n    ]\n  }\n}\n",
    "longname": "/home/runner/work/maximum-matching/maximum-matching/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "globalIndex": false,
    "content": null,
    "longname": "",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/maximum-matching/maximum-matching/doc/manual/overview.md",
    "name": "./doc/manual/overview.md",
    "content": "# Overview\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/maximum-matching/maximum-matching/doc/manual/installation.md",
    "name": "./doc/manual/installation.md",
    "content": "# Installation\n\nCan be managed using\n[yarn](https://yarnpkg.com/en/docs),\n[npm](https://docs.npmjs.com),\nor [jspm](https://jspm.org/docs).\n\n\n### yarn\n```terminal\nyarn add @graph-algorithm/maximum-matching\n```\n\n### npm\n```terminal\nnpm install @graph-algorithm/maximum-matching --save\n```\n\n### jspm\n```terminal\njspm install npm:@graph-algorithm/maximum-matching\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/maximum-matching/maximum-matching/doc/manual/usage.md",
    "name": "./doc/manual/usage.md",
    "content": "# Usage\n\n> :warning: The code needs a ES2015+ polyfill to run (`regeneratorRuntime`),\n> for instance [regenerator-runtime/runtime](https://babeljs.io/docs/usage/polyfill).\n\nFirst, require the polyfill at the entry point of your application\n```js\nrequire( 'regenerator-runtime/runtime' ) ;\n// or\nimport 'regenerator-runtime/runtime.js' ;\n```\n\nThen, import the library where needed\n```js\nconst mm = require( '@graph-algorithm/maximum-matching' ) ;\n// or\nimport * as mm from '@graph-algorithm/maximum-matching' ;\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/maximum-matching/maximum-matching/doc/manual/example.md",
    "name": "./doc/manual/example.md",
    "content": "# Examples\n\n> More examples in [the test files](https://github.com/graph-algorithm/maximum-matching/tree/main/test/src).\n",
    "static": true,
    "access": "public"
  }
]